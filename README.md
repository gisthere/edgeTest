 # Тестовое задание для Edge Vision
 Так как данный репозиторий не предоставляет особой ценности для it сообщества, то оставлю описание самого задания за рамками данного описания. 
 
 ### How to run.
 
    docker-compose up --scale sensor=8 --scale controller-celery-worker=1
    
 Команда и ее аргументы выглядят достаточно самоописательными, чтобы их можно было поменять в зависимости от цели запуска.  
 ## Ключевые решения
 - Основой стека стало flask+postgresql, как наиболее привычный(flask обуславливается отсутствием требований к высокой поддержки веб интерфейса, и служит лишь микро прослойкой между интерфесами).
 - Так как данные из сенсора необходимо обрабатывать параллельно и асинхронно, каждая задача на обработку отправляется в очередь celery(брокер redis).
 - Там же раз в 5 секунд отправляется задача на просчет результатов действия для манипулятора, там же отправляются запросы с полученными данными на веб сервер и манипулятор.
 
 ## Что было сделано хорошо
 Не утверждается, что указанное здесь, сделано хорошо(хоть это и не исключается), а хорошо, что это было сделано.
 
 - Функция(декоратор) debounce, которая регулирует количество выполнений входной функции в еденицу времени.
 - Обертка над TCP сокетами. В манипуляторе это автоподнимаемый интерфейс. В контроллере это класс, который используется как Connection Pool, хоть и в меньшей степени(см. ниже)

 ## Что можно было сделать лучше
 
 - Выделить для задач с расчетом результатов отдельную очередь, чтобы сообщения от сенсоров не "захламляли" ее, и не мешали просчету результатов.
 - Принимая предыдущее, можно было бы сделать одно TCP соединение с манипулятором и переиспользовать его, а не пересоздовать при каждом новом запросе. В текузей версии это невозможно, так как задачи из очереди могут выполняться в разных сущностях-исполнителях, между которыми нет общих данных(кроме очереди).
 - Добавить индексы в базу контроллера. Так можно бы было снизить осимптотику операций до O(log(N))
 - Можно более точнее написать функцию debounce. Которая в данный момент запускает функцию немного медленнее указанного значения, так как не учитывается время исполнения функции(то есть принимается за 0).
 
 ## Результаты
 
 В итоге у меня получилось собрать систему которая "гоняет" между собой запросы и обрабатывает их. Но что самое главное, с заявленными 100 запросами от каждого из 8 сенсоров она не справляется. 
 
 Возможные причины этому:
 
 - Слишком большое количество задач, и времени их ввыполнения на одну базу.
 - Неправильная настройка очереди сообщений, при которой задачи не успевают выполниться вовремя.
 - Неправильный выбор базы данных(а воможно и других технологий), возможно более лучшим было использовать базы, в которых возможны паралельные операции.